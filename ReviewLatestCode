//*****************************************************************************
//
// usb_dev_bulk.c - Main routines for the generic bulk device example.
//
// Copyright (c) 2013-2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
//
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
//
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
//
// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
//
//*****************************************************************************

#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/pin_map.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "usblib/usblib.h"
#include "usblib/usb-ids.h"
#include "usblib/device/usbdevice.h"
#include "usblib/device/usbdbulk.h"
#include "utils/uartstdio.h"
#include "utils/ustdlib.h"
#include "drivers/pinout.h"
#include "usb_bulk_structs.h"
#include "driverlib/adc.h"
#include "driverlib/timer.h"

//*****************************************************************************
//
//! \addtogroup example_list
//! <h1>USB Generic Bulk Device (usb_dev_bulk)</h1>
//!
//! This example provides a generic USB device offering simple bulk data
//! transfer to and from the host.  The device uses a vendor-specific class ID
//! and supports a single bulk IN endpoint and a single bulk OUT endpoint.
//! Data received from the host is assumed to be ASCII text and it is
//! echoed back with the case of all alphabetic characters swapped.
//!
//! A Windows INF file for the device is provided on the installation media and
//! in the C:/ti/TivaWare-C-Series-X.X/windows_drivers directory of TivaWare
//! releases.  This INF contains information required to install the WinUSB
//! subsystem on WindowsXP and Vista PCs.  WinUSB is a Windows subsystem
//! allowing user mode applications to access the USB device without the need
//! for a vendor-specific kernel mode driver.
//!
//! A sample Windows command-line application, usb_bulk_example, illustrating
//! how to connect to and communicate with the bulk device is also provided.
//! The application binary is installed as part of the ``TivaWare for C Series
//! PC Companion Utilities'' package (SW-TM4C-USB-WIN) on the installation CD
//! or via download from http://www.ti.com/tivaware .  Project files are
//! included to allow the examples to be built using
//! Microsoft Visual Studio 2008.  Source code for this application can be
//! found in directory ti/TivaWare_C_Series-x.x/tools/usb_bulk_example.
//
//*****************************************************************************


//*****************************************************************************
//
// The system tick rate expressed both as ticks per second and a millisecond
// period.
//
//*****************************************************************************
#define SYSTICKS_PER_SECOND 100
#define SYSTICK_PERIOD_MS   (1000 / SYSTICKS_PER_SECOND)

//*****************************************************************************
//
// The global system tick counter.
//
//*****************************************************************************
volatile uint32_t g_ui32SysTickCount = 0;

//*****************************************************************************
//
// Variables tracking transmit and receive counts.
//
//*****************************************************************************
volatile uint32_t g_ui32TxCount = 0;
volatile uint32_t g_ui32RxCount = 0;

//*****************************************************************************
//
// Flags used to pass commands from interrupt context to the main loop.
//
//*****************************************************************************
#define COMMAND_PACKET_RECEIVED 0x00000001
#define COMMAND_STATUS_UPDATE   0x00000002

volatile uint32_t g_ui32Flags = 0;
uint32_t ui32Count = 0;
uint_fast32_t ui32WriteIndex = 0, WriteIndex = 0;
uint8_t TempDataBuf[256] ;
uint8_t *pData;
uint32_t ADCDataRaw[1];
int flag = 0;
//*****************************************************************************
//
// Global flag indicating that a USB configuration has been set.
//
//*****************************************************************************
static volatile bool g_bUSBConfigured = false;

//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
}
#endif

//*****************************************************************************
//
// Interrupt handler for the system tick counter.
//
//*****************************************************************************
void
SysTickIntHandler(void)
{
    //
    // Update our system tick counter.
    //
    g_ui32SysTickCount++;
}

static uint32_t EchoNewDataToHost();
void ADCDataGet();
void ADCInit();
//*****************************************************************************
//
// Receive new data and echo it back to the host.
//
// \param psDevice points to the instance data for the device whose data is to
// be processed.
// \param pi8Data points to the newly received data in the USB receive buffer.
// \param ui32NumBytes is the number of bytes of data available to be
// processed.
//
// This function is called whenever we receive a notification that data is
// available from the host. We read the data, byte-by-byte and swap the case
// of any alphabetical characters found then write it back out to be
// transmitted back to the host.
//
// \return Returns the number of bytes of data processed.
//
//*****************************************************************************
static uint32_t
ReceiveAndRespond(tUSBDBulkDevice *psDevice, uint8_t *pi8Data,
                  uint_fast32_t ui32NumBytes)
{
	int x=0;
    uint_fast32_t ui32ReadIndex;

    g_ui32RxCount += ui32NumBytes;
    ui32ReadIndex = (uint32_t)(pi8Data - g_pui8USBRxBuffer);
    while (x<1){

    	if((g_pui8USBRxBuffer[ui32ReadIndex] >= '1') &&
    	           (g_pui8USBRxBuffer[ui32ReadIndex] <= '2')){

    		ADCSequenceDisable(ADC0_BASE, 3);
    		TimerDisable(TIMER5_BASE, TIMER_B);
    		TimerLoadSet(TIMER5_BASE, TIMER_B, 600);
    		ADCSequenceEnable(ADC0_BASE, 3);
    		TimerEnable(TIMER5_BASE, TIMER_B);

    	}
    	else if((g_pui8USBRxBuffer[ui32ReadIndex] >= '3') &&
    	           (g_pui8USBRxBuffer[ui32ReadIndex] <= '4')){

       		ADCSequenceDisable(ADC0_BASE, 3);
       		TimerDisable(TIMER5_BASE, TIMER_B);
    		TimerLoadSet(TIMER5_BASE, TIMER_B, 1800);
    		ADCSequenceEnable(ADC0_BASE, 3);
    	   	TimerEnable(TIMER5_BASE, TIMER_B);

    	}
    	else if((g_pui8USBRxBuffer[ui32ReadIndex] >= '5') &&
    	           (g_pui8USBRxBuffer[ui32ReadIndex] <= '6')){

       		ADCSequenceDisable(ADC0_BASE, 3);
       		TimerDisable(TIMER5_BASE, TIMER_B);
       		TimerLoadSet(TIMER5_BASE, TIMER_B, 2400);
       		ADCSequenceEnable(ADC0_BASE, 3);
       		TimerEnable(TIMER5_BASE, TIMER_B);

       	}
    	else if((g_pui8USBRxBuffer[ui32ReadIndex] >= '7') &&
    	           (g_pui8USBRxBuffer[ui32ReadIndex] <= '8')){

    	    ADCSequenceDisable(ADC0_BASE, 3);
    	    TimerDisable(TIMER5_BASE, TIMER_B);
    	    TimerLoadSet(TIMER5_BASE, TIMER_B, 12000);
    	    ADCSequenceEnable(ADC0_BASE, 3);
    	    TimerEnable(TIMER5_BASE, TIMER_B);

    	 }
    	else if((g_pui8USBRxBuffer[ui32ReadIndex] >= '9')){

    	    	    ADCSequenceDisable(ADC0_BASE, 3);
    	    	    TimerDisable(TIMER5_BASE, TIMER_B);
    	    	    TimerLoadSet(TIMER5_BASE, TIMER_B, 480);
    	    	    ADCSequenceEnable(ADC0_BASE, 3);
    	    	    TimerEnable(TIMER5_BASE, TIMER_B);

    	    	 }
    	x++;
    }

    return(g_ui32RxCount);
}
/*
 * This function sends the ADC data 256 samples at a time.
 * The ADC sampling speed is changed by the user.
 */

static uint32_t
EchoNewDataToHost()
{
	/*
	 * Function for sending the acquired ADC data to the laptop through USB
	 * Fill the TxBuffer at once instead of one at a time as the pointer is reset on the function call each time.
	 *
	 */

	tUSBRingBufObject sTxRing;
	WriteIndex = 0;


	    //
	    // Get the current buffer information to allow us to write directly to
	    // the transmit buffer (we already have enough information from the
	    // parameters to access the receive buffer directly).
	    //
    USBBufferInfoGet(&g_sTxBuffer, &sTxRing);


//    ui32WriteIndex = sTxRing.ui32WriteIndex;

    SysCtlDelay(5);



    ui32Count = 256;
    USBBufferWrite(&g_sTxBuffer, TempDataBuf, ui32Count);


    //
    // We processed as much data as we can directly from the receive buffer so
    // we need to return the number of bytes to allow the lower layer to
    // update its read pointer appropriately.
    //
    return(ui32Count);
}

//*****************************************************************************
//
// Handles bulk driver notifications related to the transmit channel (data to
// the USB host).
//
// \param pvCBData is the client-supplied callback pointer for this channel.
// \param ulEvent identifies the event we are being notified about.
// \param ulMsgValue is an event-specific value.
// \param pvMsgData is an event-specific pointer.
//
// This function is called by the bulk driver to notify us of any events
// related to operation of the transmit data channel (the IN channel carrying
// data to the USB host).
//
// \return The return value is event-specific.
//
//*****************************************************************************
uint32_t
TxHandler(void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgValue,
          void *pvMsgData)
{
    //
    // We are not required to do anything in response to any transmit event
    // in this example. All we do is update our transmit counter.
    //
    if(ui32Event == USB_EVENT_TX_COMPLETE)
    {
        g_ui32TxCount += ui32MsgValue;
    }
    return(0);
}

//*****************************************************************************
//
// Handles bulk driver notifications related to the receive channel (data from
// the USB host).
//
// \param pvCBData is the client-supplied callback pointer for this channel.
// \param ui32Event identifies the event we are being notified about.
// \param ui32MsgValue is an event-specific value.
// \param pvMsgData is an event-specific pointer.
//
// This function is called by the bulk driver to notify us of any events
// related to operation of the receive data channel (the OUT channel carrying
// data from the USB host).
//
// \return The return value is event-specific.
//
//*****************************************************************************
uint32_t
RxHandler(void *pvCBData, uint32_t ui32Event, uint32_t ui32MsgValue,
          void *pvMsgData)
{
    //
    // Which event are we being sent?
    //
    switch(ui32Event)
    {
        //
        // We are connected to a host and communication is now possible.
        //
        case USB_EVENT_CONNECTED:
        {
            g_bUSBConfigured = true;
            g_ui32Flags |= COMMAND_STATUS_UPDATE;

            //
            // Flush our buffers.
            //
            USBBufferFlush(&g_sTxBuffer);
            USBBufferFlush(&g_sRxBuffer);

            break;
        }

        //
        // The host has disconnected.
        //
        case USB_EVENT_DISCONNECTED:
        {
            g_bUSBConfigured = false;
            g_ui32Flags |= COMMAND_STATUS_UPDATE;
            break;
        }

        //
        // A new packet has been received.
        //
        case USB_EVENT_RX_AVAILABLE:
        {
            tUSBDBulkDevice *psDevice;

            //
            // Get a pointer to our instance data from the callback data
            // parameter.
            //
            psDevice = (tUSBDBulkDevice *)pvCBData;

            //
            // Read the new packet and echo it back to the host.
            //
            return(ReceiveAndRespond(psDevice, pvMsgData, ui32MsgValue));
        }

        //
        // Ignore SUSPEND and RESUME for now.
        //
        case USB_EVENT_SUSPEND:
        case USB_EVENT_RESUME:
            break;

        //
        // Ignore all other events and return 0.
        //
        default:
            break;
    }

    return(0);
}

void ADCDataGet()
{

	/*
	 * Interrupt for sample sequencer of ADC
	 * clear the ADC interrupt flag at the beginning of each interrupt service routine
	 * Also, declare the function name in startup_ccs file
	 */

	ADCIntClear(ADC0_BASE, 3);
	ADCSequenceDataGet(ADC0_BASE, 3, ADCDataRaw);
	ADCDataRaw[0] = ADCDataRaw[0]>>4;
	TempDataBuf[WriteIndex] = (uint8_t)ADCDataRaw[0];
	flag = 1;

}


void ADCInit()
{
	/*Enable ADC Peripheral*/
	SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
	int a = SYSCTL_PERIPH_ADC0;
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);

	GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 );

	/*Configure ADC Peripheral*/
	ADCSequenceDisable(ADC0_BASE, 3); //Before Configuring ADC Sequencer 1, it should be OFF
	ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PIOSC, 1);

	/*Configure ADC Sequence*/
	ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_TIMER, 0);
//	ADCSequenceStepConfigure(ADC0_BASE, 0, 0, ADC_CTL_CH3); //Sequencer Step 0
//	ADCSequenceStepConfigure(ADC0_BASE, 0, 1, ADC_CTL_CH2); //Sequencer Step 1
//	ADCSequenceStepConfigure(ADC0_BASE, 0, 2, ADC_CTL_CH1); //Sequencer Step 2
	ADCSequenceStepConfigure(ADC0_BASE, 3, 0, ADC_CTL_CH3| ADC_CTL_IE |ADC_CTL_END); //Sequencer Step 3

	/*Enable ADC sequence*/

	ADCSequenceEnable(ADC0_BASE, 3);


	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
	SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER5);

	GPIOPinConfigure(GPIO_PM7_T5CCP1);
	GPIOPinTypeTimer(GPIO_PORTM_BASE, GPIO_PIN_7);

	TimerConfigure(TIMER5_BASE, TIMER_CFG_SPLIT_PAIR|TIMER_CFG_B_PERIODIC);
	TimerLoadSet(TIMER5_BASE, TIMER_B, 120);

	TimerControlTrigger(TIMER5_BASE, TIMER_B, true);
	TimerEnable(TIMER5_BASE, TIMER_B);

	ADCIntDisable(ADC0_BASE, 3);

	ADCIntRegister(ADC0_BASE, 3, ADCDataGet );

	/*Clear ADC Interrupt*/
	ADCIntClear(ADC0_BASE, 3);
	ADCIntEnable(ADC0_BASE, 3);
	IntEnable(INT_ADC0SS3);
	IntMasterEnable();

}
//*****************************************************************************
//
// This is the main application entry function.
//
//*****************************************************************************
int
main(void)
{
    uint_fast32_t ui32TxCount;
    uint_fast32_t ui32RxCount;
    uint32_t ui32SysClock;
    uint_fast32_t ui32Space;
    //
    // Run from the PLL at 120 MHz.
    //
    ui32SysClock = SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ |
                                           SYSCTL_OSC_MAIN |
                                           SYSCTL_USE_PLL |
                                           SYSCTL_CFG_VCO_480), 120000000);

    //
    // Configure the device pins.
    //
    PinoutSet(false, true);

    //
    // Enable UART0
    //
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);

    //
    // Initialize the UART for console I/O.
    //
    UARTStdioConfig(0, 115200, ui32SysClock);

    //
    // Not configured initially.
    //
    g_bUSBConfigured = false;

    //
    // Enable the system tick.
    //
    SysTickPeriodSet(ui32SysClock / SYSTICKS_PER_SECOND);
    SysTickIntEnable();
    SysTickEnable();

    //
    // Show the application name on the display and UART output.
    //
    UARTprintf("\033[2J\nTiva C Series USB bulk device example\n");
    UARTprintf("---------------------------------\n\n");

    //
    // Tell the user what we are up to.
    //
    UARTprintf("Configuring USB... \n");

    //
    // Initialize the transmit and receive buffers.
    //
    USBBufferInit(&g_sTxBuffer);
    USBBufferInit(&g_sRxBuffer);

    //
    // Initialize the USB stack for device mode.
    //
    USBStackModeSet(0, eUSBModeDevice, 0);

    //
    // Pass our device information to the USB library and place the device
    // on the bus.
    //
    USBDBulkInit(0, &g_sBulkDevice);

    //
    // Wait for initial configuration to complete.
    //
    UARTprintf("Waiting for host...\r");

    //
    // Clear our local byte counters.
    //
    ui32RxCount = 0;
    ui32TxCount = 0;

    ADCInit();
    //
    // Main application loop.
    //
    while(1)
    {
    	ui32Space = USBBufferSpaceAvailable(&g_sTxBuffer);
    	if (flag == 1)
    	{
    		WriteIndex++;
    		flag = 0;
    	}
       	if (WriteIndex >= BULK_BUFFER_SIZE && ui32Space >=250)
       	{

       		EchoNewDataToHost();
       		WriteIndex = 0;
       		 USBBufferFlush(&g_sTxBuffer);
       	}
       	SysCtlDelay(5);
    }
}
